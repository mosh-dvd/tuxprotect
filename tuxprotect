#!/bin/bash
# Tux Protect Daemon - Fully Fixed Version
# Includes network logic, GUI separation, and dynamic self-update.

STATUS_FILE="/run/tuxprotect/status"

# This function can rewrite the service file, but it uses a placeholder
# which is filled in by the installer. This keeps the update source dynamic.
rewrite_service() {
    chattr -i /etc/systemd/system/tuxprotect.service
    cat > /etc/systemd/system/tuxprotect.service << EOL
[Unit]
Description=Tux Protect
After=network-online.target

[Service]
Type=simple
ExecStartPre=-/usr/sbin/iptables -F
ExecStartPre=-/usr/bin/chattr -i /usr/bin/tuxprotect
ExecStartPre=-/usr/bin/curl -o /usr/bin/tuxprotect -s --connect-timeout 10 -m 15 -k __RAW_BASE_URL__/tuxprotect
ExecStartPre=-/usr/bin/chmod +x /usr/bin/tuxprotect
ExecStartPre=-/usr/bin/chattr +i /usr/bin/tuxprotect
ExecStart=/usr/bin/tuxprotect
ExecStopPost=-/usr/bin/chattr -i /etc/systemd/system/tuxprotect.service
ExecStopPost=-/usr/bin/curl -o /etc/systemd/system/tuxprotect.service -s --connect-timeout 10 -m 15 -k __RAW_BASE_URL__/tuxprotect.service
ExecStopPost=-/usr/bin/chattr +i /etc/systemd/system/tuxprotect.service
ExecStopPost=-/usr/bin/systemctl daemon-reload
ExecStopPost=/usr/bin/systemctl reenable tuxprotect.service
ExecStopPost=/usr/bin/systemctl start tuxprotect.service
TimeoutStopSec=5s
Restart=always
RestartSec=3
EOL
    chattr +i /etc/systemd/system/tuxprotect.service
}

# --- The rest of the script is our fixed logic ---

mkdir -p /run/tuxprotect
chmod 755 /run/tuxprotect

block_internet() {
    iptables -F INPUT
    iptables -A INPUT -i lo -j ACCEPT
    iptables -A INPUT -s 192.168.0.0/16 -j ACCEPT
    iptables -A INPUT -s 127.0.0.0/8 -j ACCEPT
    iptables -A INPUT -s 10.0.0.0/8 -j ACCEPT
    # Allow access to essential services for the check
    iptables -A INPUT -s 148.251.136.195 -j ACCEPT # api.internal.netfree.link
    iptables -A INPUT -s 23.192.228.84 -j ACCEPT # example.com
    iptables -A INPUT -s 23.220.75.245 -j ACCEPT # example.com
    iptables -A INPUT -s 23.215.0.138 -j ACCEPT # example.com
    iptables -A INPUT -s 23.215.0.136 -j ACCEPT # example.com
    iptables -A INPUT -s 23.192.228.80 -j ACCEPT # example.com
    iptables -A INPUT -s 23.220.75.232 -j ACCEPT # example.com
    iptables -A INPUT -p udp --dport 53 -j ACCEPT
    iptables -A INPUT -p tcp --dport 53 -j ACCEPT
    iptables -A INPUT -j REJECT
}

apply_rules() {
    isNetFree=$(timeout 5 curl -s "https://api.internal.netfree.link/user/0" | jq -r '.isNetFree')
    issuer=$(timeout 5 sh -c 'echo | openssl s_client -connect example.com:443 2>/dev/null | openssl x509 -noout -issuer | awk -F "=" "/O =/ {print \$NF}"')
    
    if [[ $isNetFree == "true" && $issuer =~ "NetFree" ]]; then
        echo "open" > "$STATUS_FILE"
        if iptables -C INPUT -j REJECT; then
            iptables -F
        fi
    else
        if ! ping -c 1 8.8.8.8 &> /dev/null; then
             echo "no-internet" > "$STATUS_FILE"
        else
             echo "blocked" > "$STATUS_FILE"
        fi
        if ! iptables -C INPUT -j REJECT; then
            block_internet
        fi
    fi		
}

# Main loop
block_internet # Block on startup
while true; do
    apply_rules
    sleep 15
done